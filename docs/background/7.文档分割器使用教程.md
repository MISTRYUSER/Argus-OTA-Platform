## 一、引言

本文档将介绍文档分割器（Document Splitter）的使用方法，该组件用于将长文档分割为适合处理的小块（Chunk），支持普通文本和 Markdown 格式文档的分割，可保持文档的语义完整性。

## 二、核心组件说明

文档分割器的核心是 `DocumentSplitterService` 结构体，它封装了文档分割的核心逻辑，提供了灵活的配置和多种分割方法。主要支持两种场景：

- 普通文本分割
    
- Markdown 文档分割（保留 Markdown 结构语义）
    

## 三、代码文件详解

### 1. splitter.go

该文件定义了文档分割器的基础服务结构和通用分割方法，是整个分割功能的核心实现。

#### 主要内容：

- 定义 `DocumentSplitterService` 结构体，包含分割器配置（`config`）和底层转换器（`splitter`）
    
- 提供服务初始化方法 `NewDocumentSplitterService`，支持自定义配置（块大小、重叠大小、分隔符等），并设置默认值
    
- 实现通用分割方法：
    
    - `Split`：批量分割文档列表
        
    - `SplitText`：分割单个文本内容
        
- 提供 `GetConfig` 方法获取当前配置
    

```Go
package splitter

import (
    "context"
    "fmt"

    "github.com/cloudwego/eino-ext/components/document/transformer/splitter/recursive"
    "github.com/cloudwego/eino/components/document"
    "github.com/cloudwego/eino/schema"
)

//参考文档 https://www.cloudwego.io/zh/docs/eino/ecosystem_integration/document/splitter_recursive/

// DocumentSplitterService 封装文档分割器服务
type DocumentSplitterService struct {
    config   *recursive.Config
    splitter document.Transformer
}

// NewDocumentSplitterService 创建新的文档分割器服务
func NewDocumentSplitterService(ctx context.Context, config *recursive.Config) (*DocumentSplitterService, error) {
    if config == nil {
        return nil, fmt.Errorf("config is nil")
    }
    // 设置默认值
    if config.ChunkSize <= 0 {
        config.ChunkSize = 1000
    }
    if config.OverlapSize < 0 {
        config.OverlapSize = 200
    }
    if len(config.Separators) == 0 {
        // 中英文混合的默认分隔符
        config.Separators = []string{"\n\n", "\n", "。", "！", "？", ". ", "! ", "? "}
    }
    // 创建分割器
    splitter, err := recursive.NewSplitter(ctx, &recursive.Config{
        ChunkSize:   config.ChunkSize,
        OverlapSize: config.OverlapSize,
        Separators:  config.Separators,
        KeepType:    config.KeepType,
        LenFunc:     nil, // 使用默认的长度计算函数
    })
    if err != nil {
        return nil, fmt.Errorf("failed to create document splitter: %w", err)
    }
    return &DocumentSplitterService{
        config:   config,
        splitter: splitter,
    }, nil
}

// Split 分割文档
func (s *DocumentSplitterService) Split(ctx context.Context, docs []*schema.Document) ([]*schema.Document, error) {
    if len(docs) == 0 {
        return nil, fmt.Errorf("docs is empty")
    }

    results, err := s.splitter.Transform(ctx, docs)
    if err != nil {
        return nil, fmt.Errorf("failed to split documents: %w", err)
    }

    return results, nil
}

// SplitText 分割单个文本内容
func (s *DocumentSplitterService) SplitText(ctx context.Context, text string) ([]*schema.Document, error) {
    if text == "" {
        return nil, fmt.Errorf("text is empty")
    }

    doc := &schema.Document{
        Content: text,
    }

    return s.Split(ctx, []*schema.Document{doc})
}

// GetConfig 获取配置信息
func (s *DocumentSplitterService) GetConfig() *recursive.Config {
    return s.config
}
```

#### 关键配置说明：

- `ChunkSize`：分割后每个块的大小（默认 1000）
    
- `OverlapSize`：块之间的重叠内容大小（默认 200）
    
- `Separators`：分割符列表（默认提供中英文混合分隔符，如换行、句号、感叹号等）
    

### 2. markdown.go

该文件扩展了 `DocumentSplitterService`，提供专为 Markdown 文档设计的分割方法，通过适配 Markdown 结构的分隔符，更好地保持文档语义。

```Go
package splitter

import (
    "context"
    "fmt"

    "github.com/cloudwego/eino-ext/components/document/transformer/splitter/recursive"
    "github.com/cloudwego/eino/schema"
)

// SplitMarkdown 专门用于切割 Markdown 文档的方法
// 使用适合 Markdown 结构的分隔符，保持文档的语义完整性
func (s *DocumentSplitterService) SplitMarkdown(ctx context.Context, markdownContent string) ([]*schema.Document, error) {
    if markdownContent == "" {
        return nil, fmt.Errorf("markdown content is empty")
    }

    // 创建专门用于 Markdown 的配置
    // 使用适合 Markdown 的分隔符，优先级从高到低
    markdownSeparators := []string{
        "\n\n\n",    // 多个空行（章节分隔）
        "\n## ",     // 二级标题
        "\n### ",    // 三级标题
        "\n#### ",   // 四级标题
        "\n##### ",  // 五级标题
        "\n###### ", // 六级标题
        "\n# ",      // 一级标题（放在后面，避免误匹配）
        "\n\n",      // 段落分隔
        "\n```",     // 代码块开始
        "\n---",     // 水平分割线
        "\n***",     // 水平分割线
        "\n- ",      // 无序列表
        "\n* ",      // 无序列表
        "\n1. ",     // 有序列表
        "\n2. ",     // 有序列表
        "\n3. ",     // 有序列表
        "\n",        // 单行分隔
        "。",         // 中文句号
        "！",         // 中文感叹号
        "？",         // 中文问号
        ". ",        // 英文句号
        "! ",        // 英文感叹号
        "? ",        // 英文问号
    }

    // 创建临时的 Markdown 分割器配置
    markdownConfig := &recursive.Config{
        ChunkSize:   s.config.ChunkSize,   // 使用原有配置的块大小
        OverlapSize: s.config.OverlapSize, // 使用原有配置的重叠大小
        Separators:  markdownSeparators,   // 使用 Markdown 专用分隔符
        KeepType:    s.config.KeepType,    // 保持原有类型设置
    }

    // 创建临时的 Markdown 分割器
    markdownSplitter, err := recursive.NewSplitter(ctx, markdownConfig)
    if err != nil {
        return nil, fmt.Errorf("failed to create markdown splitter: %w", err)
    }

    // 创建文档对象
    doc := &schema.Document{
        Content: markdownContent,
    }

    // 执行分割
    results, err := markdownSplitter.Transform(ctx, []*schema.Document{doc})
    if err != nil {
        return nil, fmt.Errorf("failed to split markdown document: %w", err)
    }

    return results, nil
}

// SplitMarkdownDocuments 批量切割多个 Markdown 文档
func (s *DocumentSplitterService) SplitMarkdownDocuments(ctx context.Context, docs []*schema.Document) ([]*schema.Document, error) {
    if len(docs) == 0 {
        return nil, fmt.Errorf("docs is empty")
    }

    // Markdown 专用分隔符
    markdownSeparators := []string{
        "\n\n\n",
        "\n## ",
        "\n### ",
        "\n#### ",
        "\n##### ",
        "\n###### ",
        "\n# ",
        "\n\n",
        "\n```",
        "\n---",
        "\n***",
        "\n- ",
        "\n* ",
        "\n1. ",
        "\n2. ",
        "\n3. ",
        "\n",
        "。",
        "！",
        "？",
        ". ",
        "! ",
        "? ",
    }

    // 创建临时的 Markdown 分割器配置
    markdownConfig := &recursive.Config{
        ChunkSize:   s.config.ChunkSize,
        OverlapSize: s.config.OverlapSize,
        Separators:  markdownSeparators,
        KeepType:    s.config.KeepType,
    }

    // 创建临时的 Markdown 分割器
    markdownSplitter, err := recursive.NewSplitter(ctx, markdownConfig)
    if err != nil {
        return nil, fmt.Errorf("failed to create markdown splitter: %w", err)
    }

    // 执行分割
    results, err := markdownSplitter.Transform(ctx, docs)
    if err != nil {
        return nil, fmt.Errorf("failed to split markdown documents: %w", err)
    }

    return results, nil
}
```

#### 主要内容：

- 实现 `SplitMarkdown` 方法：分割单个 Markdown 文本内容
    
- 实现 `SplitMarkdownDocuments` 方法：批量分割 Markdown 文档列表
    
- 使用 Markdown 专用分隔符（按优先级排序），包括：
    
    - 章节分隔（多空行）
        
    - 各级标题（##、### 等）
        
    - 代码块（```）
        
    - 水平分割线（---、***）
        
    - 列表项（- 、* 、1. 等）
        
    - 普通文本分隔符（换行、句号等）
        

## 四、注意事项

  

1. 配置参数：`ChunkSize` 和 `OverlapSize` 的设置需根据实际场景调整，过大会导致块处理效率低，过小可能破坏语义完整性
    
2. 空输入处理：所有分割方法均会对空输入（空文本、空文档列表）返回错误，使用时需提前校验
    
3. Markdown 分割：专用分割方法会优先按 Markdown 结构分割，更适合需要保留标题、列表等结构语义的场景
    
4. 错误处理：初始化和分割过程中可能产生错误（如配置无效、分割逻辑异常），需妥善处理返回的错误信息
    

以上就是文档分割器的核心使用方法，具体实现可参考对应代码文件：

- 基础功能：splitter.go
    
- Markdown 扩展功能：markdown.go