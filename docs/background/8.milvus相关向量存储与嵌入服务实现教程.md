## 引言

  

本文档将介绍基于Milvus和Ark嵌入模型的向量存储与处理相关代码实现，包含三个核心文件：`storage/converter.go`、`storage/indexer.go`和`storage/embedding.go`。这些文件共同实现了文档到向量的转换、向量嵌入生成以及向量数据在Milvus中的存储功能，为MCP（多模态内容处理）相关场景提供基础支持。

## 核心文件详解

  

### 1. 数据结构与转换：`storage/converter.go`

该文件主要定义了适配Milvus存储的浮点向量数据结构，以及将通用文档格式转换为该结构的工具函数。

#### 主要功能

- 定义`FloatVectorSchema`结构体：对应Milvus中的表结构，包含文档ID、内容、向量和元数据字段
    
- 实现`FloatVectorDocumentConverter`函数：将`schema.Document`类型转换为`FloatVectorSchema`类型，完成元数据序列化和向量类型转换（float64转float32）
    

#### 关键说明

- 结构体字段通过`milvus`标签指定Milvus中的字段名，便于映射
    
- 元数据使用`sonic`进行JSON序列化，确保存储格式一致性
    
- 向量类型转换是为了适配Milvus的浮点向量字段类型
    

```Go
package storage

import (
    "context"
    "fmt"

    "github.com/bytedance/sonic"
    "github.com/cloudwego/eino/schema"
)

// FloatVectorSchema 定义浮点向量的数据结构（相当于表的结构）
type FloatVectorSchema struct {
    ID       string    `json:"id" milvus:"name:id"`
    Content  string    `json:"content" milvus:"name:content"`
    Vector   []float32 `json:"vector" milvus:"name:vector"`
    Metadata []byte    `json:"metadata" milvus:"name:metadata"`
}

// FloatVectorDocumentConverter 将 schema.Document 转换为浮点向量格式
func FloatVectorDocumentConverter(ctx context.Context, docs []*schema.Document, vectors [][]float64) ([]interface{}, error) {
    if len(docs) != len(vectors) {
        return nil, fmt.Errorf("docs and vectors length mismatch: %d != %d", len(docs), len(vectors))
    }
    rows := make([]interface{}, 0, len(docs))
    for idx, doc := range docs {
        // 序列化 metadata
        metadata, err := sonic.Marshal(doc.MetaData)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal metadata: %w", err)
        }
        vector := make([]float32, len(vectors[idx]))
        for i, v := range vectors[idx] {
            vector[i] = float32(v)
        }
        row := &FloatVectorSchema{
            ID:       doc.ID,
            Content:  doc.Content,
            Vector:   vector,
            Metadata: metadata,
        }
        rows = append(rows, row)
    }

    return rows, nil
}
```

### 2. Milvus索引服务：`storage/indexer.go`

  

该文件封装了基于Milvus的索引服务，负责初始化Milvus连接、定义集合结构以及提供文档存储功能。

  

#### 主要功能

- 定义`IndexerService`结构体：封装Milvus索引器实例和配置
    
- 实现`NewIndexerServiceWithDimension`函数：创建索引服务实例，初始化Milvus集合结构（包含id、vector、content、metadata字段）
    
- 提供`Store`方法：将文档存储到Milvus中
    
- 提供索引器和配置的获取方法
    

#### 关键说明

- 显式指定向量字段为浮点类型（`FieldTypeFloatVector`），支持HNSW等高效索引
    
- 支持COSINE度量类型，适用于浮点向量的相似度计算
    
- 集合字段定义包含主键id、向量字段、内容字段和元数据字段，满足文档存储的基本需求
    

（代码内容位于`storage/indexer.go`，此处省略具体代码，可自行填充）

```Go
package storage

import (
    "context"
    "fmt"

    "github.com/cloudwego/eino-ext/components/indexer/milvus"
    "github.com/cloudwego/eino/schema"
    "github.com/milvus-io/milvus-sdk-go/v2/entity"
)

//参考文档 https://www.cloudwego.io/zh/docs/eino/ecosystem_integration/indexer/indexer_milvus/

// IndexerService 封装 Milvus 索引器服务
type IndexerService struct {
    indexer *milvus.Indexer
    config  *milvus.IndexerConfig
}

// NewIndexerServiceWithDimension 创建新的索引器服务（指定维度）
func NewIndexerServiceWithDimension(ctx context.Context, config *milvus.IndexerConfig, dimension int) (*IndexerService, error) {
    if config == nil {
        return nil, fmt.Errorf("config is nil")
    }
    if config.Client == nil {
        return nil, fmt.Errorf("milvus client is nil")
    }
    if config.Collection == "" {
        return nil, fmt.Errorf("collection name is required")
    }
    if config.Embedding == nil {
        return nil, fmt.Errorf("embedding is required")
    }
    if dimension <= 0 {
        return nil, fmt.Errorf("dimension must be positive, got %d", dimension)
    }
    // 构建 Milvus Indexer 配置
    // 使用浮点向量字段以支持 HNSW 等高效索引
    indexerConfig := &milvus.IndexerConfig{
        Client:     config.Client,
        Collection: config.Collection,
        Embedding:  config.Embedding,
        // 显式指定字段，使用 FloatVector 而非默认的 BinaryVector
        Fields: []*entity.Field{
            entity.NewField().
                WithName("id").
                WithDescription("the unique id of the document").
                WithIsPrimaryKey(true).
                WithDataType(entity.FieldTypeVarChar).
                WithMaxLength(255),
            entity.NewField().
                WithName("vector").
                WithDescription("the vector of the document").
                WithIsPrimaryKey(false).
                WithDataType(entity.FieldTypeFloatVector). // 使用浮点向量
                WithDim(int64(dimension)),                 // 使用传入的向量维度
            entity.NewField().
                WithName("content").
                WithDescription("the content of the document").
                WithIsPrimaryKey(false).
                WithDataType(entity.FieldTypeVarChar).
                WithMaxLength(4096), // 增加长度以支持更长的文档
            entity.NewField().
                WithName("metadata").
                WithDescription("the metadata of the document").
                WithIsPrimaryKey(false).
                WithDataType(entity.FieldTypeJSON),
        },
        // 使用 L2 或 COSINE 度量类型（适用于浮点向量）
        MetricType:        milvus.COSINE,
        DocumentConverter: FloatVectorDocumentConverter,
    }
    // 创建 Indexer
    indexer, err := milvus.NewIndexer(ctx, indexerConfig)
    if err != nil {
        return nil, fmt.Errorf("failed to create milvus indexer: %w", err)
    }
    return &IndexerService{
        indexer: indexer,
        config:  config,
    }, nil
}

// Store 存储文档到 Milvus
func (s *IndexerService) Store(ctx context.Context, docs []*schema.Document) ([]string, error) {
    if s.indexer == nil {
        return nil, fmt.Errorf("indexer is not initialized")
    }
    ids, err := s.indexer.Store(ctx, docs)
    if err != nil {
        return nil, fmt.Errorf("failed to store documents: %w", err)
    }
    return ids, nil
}

// GetIndexer 获取底层的 Indexer 实例
func (s *IndexerService) GetIndexer() *milvus.Indexer {
    return s.indexer
}

// GetConfig 获取配置
func (s *IndexerService) GetConfig() *milvus.IndexerConfig {
    return s.config
}
```

  

### 3. 嵌入服务：`storage/embedding.go`

  

该文件封装了Ark嵌入模型服务，负责将文本转换为向量表示，为向量存储提供原始向量数据。

  

#### 主要功能

- 定义`EmbeddingService`结构体：封装嵌入器实例和配置
    
- 实现`NewArkEmbeddingService`函数：创建Ark嵌入服务实例，验证并初始化配置（包含API密钥、模型、超时等）
    
- 提供`EmbedBatch`方法：批量将文本转换为float64向量
    
- 提供模型信息、嵌入器实例获取及服务关闭方法
    

#### 关键说明

- 支持两种认证方式：APIKey或AccessKey/SecretKey
    
- 提供默认配置（如BaseURL、Region、超时时间、重试次数），简化初始化流程
    
- 适配Ark嵌入模型的API，为文档向量生成提供基础能力
    

（代码内容位于`storage/embedding.go`，此处省略具体代码，可自行填充）

```Go
package storage

import (
    "context"
    "fmt"
    "time"

    "github.com/cloudwego/eino-ext/components/embedding/ark"
    "github.com/cloudwego/eino/components/embedding"
)

// 参考文档：https://www.cloudwego.io/zh/docs/eino/ecosystem_integration/embedding/embedding_ark/

// EmbeddingService Embedding服务包装
type EmbeddingService struct {
    embedder embedding.Embedder
    config   *ark.EmbeddingConfig
}

// NewArkEmbeddingService 创建新的Embedding服务
func NewArkEmbeddingService(ctx context.Context, config *ark.EmbeddingConfig) (*EmbeddingService, error) {
    if config == nil {
        return nil, fmt.Errorf("embedding config is nil")
    }
    // 验证配置
    if config.APIKey == "" && (config.AccessKey == "" || config.SecretKey == "") {
        return nil, fmt.Errorf("must provide APIKey or AccessKey/SecretKey")
    }
    if config.Model == "" {
        return nil, fmt.Errorf("model is required")
    }
    // 设置默认值
    if config.BaseURL == "" {
        config.BaseURL = "https://ark.cn-beijing.volces.com/api/v3"
    }
    if config.Region == "" {
        config.Region = "cn-beijing"
    }
    defaultTimeout := 30 * time.Second
    if config.Timeout == nil {
        config.Timeout = &defaultTimeout
    }
    defaultRetryTimes := 3
    if config.RetryTimes == nil {
        config.RetryTimes = &defaultRetryTimes
    }
    // 构建 Ark Embedding 配置
    arkConfig := &ark.EmbeddingConfig{
        Model:   config.Model,
        BaseURL: config.BaseURL,
        Region:  config.Region,
    }
    // 设置认证方式
    if config.APIKey != "" {
        arkConfig.APIKey = config.APIKey
    } else {
        arkConfig.AccessKey = config.AccessKey
        arkConfig.SecretKey = config.SecretKey
    }
    // 设置可选配置
    timeout := config.Timeout
    arkConfig.Timeout = timeout
    retryTimes := config.RetryTimes
    arkConfig.RetryTimes = retryTimes
    // 创建 embedder
    embedder, err := ark.NewEmbedder(ctx, arkConfig)
    if err != nil {
        return nil, fmt.Errorf("failed to create ark embedder: %w", err)
    }
    return &EmbeddingService{
        embedder: embedder,
        config:   config,
    }, nil
}

// EmbedBatch 批量将文本转换为向量
func (s *EmbeddingService) EmbedBatch(ctx context.Context, texts []string) ([][]float64, error) {
    if len(texts) == 0 {
        return nil, fmt.Errorf("texts is empty")
    }

    vectors, err := s.embedder.EmbedStrings(ctx, texts)
    if err != nil {
        return nil, fmt.Errorf("failed to embed texts: %w", err)
    }

    return vectors, nil
}

// GetModel 获取模型名称
func (s *EmbeddingService) GetModel() string {
    return s.config.Model
}

// GetEmbedder 获取底层的 Embedder 实例（用于 Retriever 等组件）
func (s *EmbeddingService) GetEmbedder() embedding.Embedder {
    return s.embedder
}

// Close 关闭服务
func (s *EmbeddingService) Close() error {
    // 如果 embedder 有 Close 方法，可以在这里调用
    return nil
}
```

## 总结

- `converter.go`：负责数据格式转换，是文档与Milvus存储结构之间的桥梁
    
- `indexer.go`：提供Milvus索引与存储能力，是向量数据的管理中心
    
- `embedding.go`：提供文本到向量的转换能力，是向量数据的生成源头
    

这三个文件协同工作，形成了从文本输入到向量存储的完整流程，可作为MCP场景中向量数据库应用的基础组件。